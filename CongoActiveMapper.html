<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Active learning mapping in Congo</title>
    <meta charset="utf-8" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/lucy.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/middlebury-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="themes\class1.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Active learning mapping in Congo

---


## Background and Objective


A crop field in the congo 

This project builds upon the work done on the Mapping Africa project.
The project seeks to implement the exsting Active Learning Framwork from Ghana to the Congo.
The project is computational powered by AWS (EC2 for compute and S3 for storage) and has a large human feedbackloop.


There are four major mapping components:

    1) image acquisition and pre-processing 
    
    2) training data 
    
    3) machine learning
    
    4) segmentation 



Above is the overal AOI 

---

## 1) Image acquisition - Noah
The first stage is Image acquisition
This was completed using EC2 and Planet Scope Imagery.Planet Scope Satellites are box satellites provide high temporal and spatial resolution for cropland identification. 
Two time frames: 

     1) Dry season (December-February)
     
     2) Wet season (May - September)
  











Composite image on the right is growing season, and on the left is non-growing season.

---

## 2) Training data collection -Priyanka and Wei Hong


The images were then process in Amazon EC2, 200 training sites were randomly selected from the AOIs.
The sites are then stored in postgres. 


Training site classfiers from the spatial collective in Africa access a OpenLayers.
The classifiers from the spatial collect work on creating training and validation data.


![After](/figure/EOsettlemnt.png)

&lt;!-- ```{r, echo=FALSE, out.width='95%', message = FALSE, warning = FALSE} --&gt;
&lt;!-- knitr::include_graphics(here::here("Desktop/EOsettlemnt.png")) --&gt;
&lt;!-- ``` --&gt;


Settlement Locations (datafromHDX) and the buffer sights

 
--- 


## 3) Machine learning/ (Future)
In this stage the human / machine and machine connection is established.
A "custom crowdsourcing platfrom" is created.

This platfrom is called labeller wich is built around human assessors that complete tasks, includes building data for understanding accuracy and data training.
Mapper is established for classfication, which uses a random forest algorithm. In this case, it has 80 trees.


---

## Conclusion
The final two steps are the active feedback loop and segmentation.
This segmentation (field segmentation) step is powered by a meanshift algorithm (Yizong Cheng, 1995) and followed up by a accuracy assessment.
The challange of creating a automated system for cropland segmentaion in heavily forested and remote areas.
Requires care towards accuarcy and limiting factors.
    


---

## Thank you
Lyndon, Su and Lei
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
